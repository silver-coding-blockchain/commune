import commune as c
import streamlit as st
from typing import *
import json
import paramiko
import os

class SSH(c.Module):
    @classmethod
    def cmd(cls, *cmd_args, 
                host:str= None,  
                cwd:str=None, 
                verbose=False, 
                sudo=False, 
                key=None, 
                timeout=10,  
                generator=True,
                **kwargs ):
        """s
        Run a command on a remote server using Remote.

        :param host: Hostname or IP address of the remote machine.
        :param port: Remote port (typically 22).
        :param username: Remote username.
        :param password: Remote password.
        :param command: Command to be executed on the remote machine.
        :return: Command output.
        """
        command = ' '.join(cmd_args).strip()
        
        if command.startswith('c '):
            command = command.replace('c ', cls.executable_path + ' ')

        if cwd != None:
            command = f'cd {cwd} && {command}'

        # Create an Remote client instance.
        client = paramiko.SSHClient()

        # Automatically add the server's host key (this is insecure and used for demonstration; 
        # in production, you should have the remote server's public key in known_hosts)
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                
        # Connect to the remote server
        client.connect(host['host'],
                       port=host['port'], 
                       username=host['user'], 
                       password=host['pwd'])
        
        if sudo and host['user'] != "root":
            command = "sudo -S -p '' %s" % command
            
        stdin, stdout, stderr = client.exec_command(command)

        try:
            if sudo:
                stdin.write(host['pwd'] + "\n")
                stdin.flush()
            color = c.random_color()
            # Print the output of ls command
            outputs = {'error': '', 'output': ''}

            if generator:
                for line in stdout.readlines():
                    if verbose:
                        c.print(f'[bold]{host["host"]}[/bold]', line.strip('\n'), color=color)
                    yield line

            for line in stdout.readlines():
                if verbose:
                    c.print(f'[bold]{host_name}[/bold]', line.strip('\n'), color=color)
                outputs['output'] += line

            for line in stderr.readlines():
                if verbose:
                    c.print(f'[bold]{host_name}[/bold]', line.strip('\n'))
                outputs['error'] += line
        
            if len(outputs['error']) == 0:
                outputs = outputs['output']
    
            # stdin.close()
            # stdout.close()
            # stderr.close()
            # client.close()
        except Exception as e:
            c.print(e)
        return outputs


    key_path = os.path.expanduser('~/.ssh/id_ed25519')
    public_key_path = key_path + '.pub'


    def public_key_text(self):
        return c.get_text(self.public_key_path)


    def public_key(self):
        return self.public_key_text().split('\n')[0].split(' ')[1]

    def create_key(self, key:str = None):
        if key == None:
            key = self.key_path
        return c.cmd(f'ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519')
    



    @classmethod
    def ssh_key(cls, key_file=os.path.expanduser('~/.ssh/id_rsa'),
                            passphrase=None):
        c.ensure_lib('paramiko')
        import paramiko
        key = paramiko.RSAKey.generate(bits=2048)

        # Save the private key to a file
        key.write_private_key_file(key_file, password=passphrase)

        # Save the public key to a file
        ssh_key_path = f"{key_file}.pub"
        with open(ssh_key_path, "w") as pub_key_file:
            pub_key_file.write(f"{key.get_name()} {key.get_base64()} Generated by Python")
        
        c.print(f"SSH key pair generated and saved to {ssh_key_path}")


    @classmethod
    def ssh_authorized_keys(cls, authorized_keys_file:str='~/.ssh/authorized_keys'):
        
        authorized_keys_file = os.path.expanduser(authorized_keys_file)
        if not os.path.exists(authorized_keys_file):
            return ''
        return cls.get_text(authorized_keys_file)
    


    @staticmethod
    def get_public_key_from_file(public_key_file='~/.ssh/id_rsa.pub'):
        public_key_file = os.path.expanduser(public_key_file)
        os.path.exists(public_key_file), f'public key file {public_key_file} does not exist'
        with open(public_key_file, 'r') as key_file:
            public_key_data = key_file.read().strip()

        # Extract the public key from the data
        public_key = None
        if public_key_data.startswith("ssh-rsa"):
            public_key = public_key_data

        return public_key
      

    ssh_path = os.path.expanduser('~/.ssh/id_rsa')


    @classmethod
    def resolve_ssh_path(cls, ssh_path=None):
        if ssh_path is None:
            ssh_path = cls.ssh_path
        return os.path.expanduser(ssh_path)

    @classmethod
    def ssh_pubkey(cls,ssh_path=None):
        ssh_path = cls.resolve_ssh_path(ssh_path + '.pub')
        return cls.get_text(ssh_path)
    @classmethod
    def generate_ssh_key_pair(cls, path=None,
                            passphrase=None):
        if passphrase is None:
            passphrase = c.hash(c.get_key('module').mnemonic)
            c.print(passphrase)
        path = cls.resolve_ssh_path(path)
        import paramiko
        key = paramiko.RSAKey.generate(bits=2048)

        # Save the private key to a file
        key.write_private_key_file(path, password=passphrase)

        # Save the public key to a file
        with open(path, "w") as pub_key_file:
            pub_key_file.write(f"{key.get_name()} {key.get_base64()}")
        
        return cls.ssh_pubkey(path) 
    


    @classmethod
    def id_rsa(cls, path=None):
        path = cls.resolve_ssh_path(path)
        return cls.get_text(path)
    
    @classmethod
    def id_rsa_pub(cls, path=None):
        path = cls.resolve_ssh_path(path)
        return cls.get_text(f'{path}.pub')


    @classmethod
    def add_ssh_key(cls,public_key:str, authorized_keys_file:str='~/authorized_keys'):
        authorized_keys_file = os.path.expanduser(authorized_keys_file)
        with open(authorized_keys_file, 'a') as auth_keys_file:
            auth_keys_file.write(public_key)
            auth_keys_file.write('\n')
            
        c.print('Added the key fam')